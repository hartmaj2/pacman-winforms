\documentclass[a4]{article}
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{hyperref}

\hypersetup{colorlinks=true,linkcolor=black,pdftitle={Vážení kaštanů - Doprovodný dokument},}

\graphicspath{{images/}}

\title{Czech-Man
\\Doprovodný dokument}
\author{Autor: Jan Hartman
\\Garant: RNDr. Tomáš Holan, Ph.D.
\\\\Studium: bakalářské, 1. ročník, letní semestr 2022/2023
\\Předmět: Programování 2}

\date{\today}

\begin{document}
\maketitle
\tableofcontents
\pagestyle{fancy}
\newpage
\section{Úvodní část}
\subsection{Anotace}
Program Czech-Man je napodobeninou klasické hry Pac-Man z roku 1980. Neklade si za cíl být naprosto přesnou kopií hry, hlavní funkčnosti by měly být zachovány. Hra je vyvíjena v programovacím jazyce C\#.
\subsection{Formát tohoto dokumentu}
Pokud se v tomto dokumentu budu vyjadřovat k nějaké třídě nebo objektu jejím jménem, jako je v programu tak budu psát \textbf{tučně}. Jako třeba pokud zmiňuji třídu \textbf{GameManager}.
\\\\
Naopak pokud zmiňuji nějaké klíčové slovo jazyka C\# nebo nějakou built-in třídu, tak budu používat formát \verb|verbatim|. Například \verb|char| nebo \verb|Bitmap|.
\subsection{Zvolené vývojové prostředí}
Prvotním úmyslem bylo hru vyvíjet ve vývojovém prostředí Unity, které je přímo určeno k vytváření počítačových her. S Unity jsem však neměl žádné předchozí zkušenosti a po krátké snaze naučit se základy fungování tohoto prostředí jsem jeho užití zavrhl, jelikož naučit se v tomto prostředí pracovat vyžaduje mnoho specifických znalostí. Zároveň mi prostředí Unity nevyhovovalo v jeho zaměření na přesné fyzikální simulace a také fakt, že se nedá toto zaměření plně „odstínit“. Chtěl jsem pracovat v takovém prostředí, kde budu mít nad svým herním světem co největší kontrolu, a tak jsem se nakonec rozhodl pro složitější postup, který mi však umožnil mít více kontroly nad programem.
\\\\
Touto volbou bylo pracovat v prostředí Windows Forms (dále už jen Winforms). To má zase nevýhodu v tom, že není zdaleka určeno pro tvorbu počítačových her, ale spíš k vytváření více méně statických okenních aplikací. Tím jsem se však nenechal odradit, jelikož žádné jiné prostředí podporující grafické prvky jsem neuměl používat a trvalo by mi dost času se s jakýmkoliv jiným naučit.
\newpage
\section{Programátorská část}
\subsection{Hlavní principy sledované při tvorbě programu}
\subsubsection{Obecnost a přenositelnost kódu do budoucna}
Při psaní kódu jsem se snažil hlavně dbát na to, aby byl program psán co nejvíce obecně a tudíž abych měl co největší prostor program do budoucna rozvíjet jakýmikoliv směry. Chtěl jsem také si nechat otevřenou možnost v budoucnu přejít na jiné vývojové prostředí než Winforms a dbal jsem tedy na to, ať je na Winforms všechna logika hry kromě samotného vykreslování co nejvíce nezávislá. Toto mě vedlo například k úplnému odstranění vizuálního designeru formy, jelikož jsem chtěl co nejvíce funkčnosti obsažené v samotném kódu, ze kterého by se v budoucnu dalo vyčíst, jak program převést do jiného prostředí lépe než z interních nastavení Winforms.
\subsubsection{Objektová orientace}
Snažil jsem se také programovat co možná nejvíce objektově. Dával jsem tedy důraz na to, aby všechno ve hře byl nějaký objekt. Zde jsem možná zaběhl do přílišných extrémů a můj kód je proto delší než by mohl být. Upřednostňuji však vždy delší kód, pokud tím získám lepší přehlednost a znovupoužitelnost kódu. Tím, že téměř každou věc reprezentuji objektem si nezavírám dveře před tím, abych mohl k jakémukoliv takovému objektu později přidat i nějaké chování a to mi přijde jako velmi pozitivní vlastnost.
\subsubsection{Čitelný kód}
Dalším principem, kterého jsem se snažil držet byl důraz na tzv. „samokomentující“ kód. To znamená, že jsem dbal velmi na to, aby jména proměnných byla co nejvíce výstižná a opravdu popisovala, co dané objekty, proměnné nebo funkce znamenají či dělají. Nebál jsem se proto klidně i delších jmen pokud mi přišlo, že by to pomohlo budoucímu čtenáři se v kódu lépe zorientovat. Zde jsem se však přistihl, že možná také zabíhám do přílišných extrémů. Během tvorby programu jsem si také uvědomil, že nemá smysl ve jménu proměnné slepě opakovat typ proměnné, ale snažit se trefným pojmenováním objektu v aktuálním kontextu přidat informační hodnotu navíc.
\subsubsection{Zapouzdření privátních dat}
V neposlední řadě jsem pak usiloval o to, aby každý objekt zpřístupňoval navenek jen ty informace, které jsou potřeba a více ne. To se vyplácí z toho důvodu, že je jasnější, jaký je záměr jaké funkce. Zdali má daná funkce být pouze malou pomocnou funkcí nebo něčím klíčovým, čím objekt komunikuje navenek. Dále to také usnadňuje práci z našeptávačem, který mi zbytečně nenabízí ty funkce, které stejně nebudu chtít na daném objektu nikdy volat.
\subsection{Chronologický postup tvorby}
Zde se pokusím popsat, jak se program postupně vyvíjel a jak na sobě jednotlivé důležité části programu časově navazují. Mám pocit, že je to užitečná informace, která slouží k pochopení, proč jsou různé věci řešeny tak jak jsou řešeny a dá lepší přehled o tom, jaké části programu jsou závislé na jakých jiných.
\subsubsection{Načítání vstupních dat}
Nejprve bylo nutné vůbec se rozhodnout, jak budu reprezentovat vstupní data. Rozhodl jsem se, že nejjednodušší bude zadávat herní mapu jako textový soubor, ve kterém jednotlivé symboly budou znamenat různé herní objekty. Rozhodl jsem se také zadávat soubory pomocí funkce Resources, kterou umožňuje Visual Studio, ale to jsem později změnil, jelikož mi přišlo příliš krkolomné přidávat takto nové obrázky. Je jednodušší mít jednu složku, ze které akorát přečtu soubor s daným jménem. Zároveň aby se projevily změny, tak je při využití Resources nutné také klikat na volbu Clean Build, což také přidává zbytečný krok navíc. 
\\\\
Jinak jsem se snažil vstupní data co nejvíce oddělit od zbytku programu a založil jsem tedy samostatnou statickou třídu \textbf{InputManager}, která se stará o vše co se týká načítání a předzpracování vstupních dat.
\\\\
Na načítání vstupních dat bych však také chtěl ještě opravit způsob, kterým jsou vstupní data předávány samotným objektům. Přijde mi lepší, aby objekty dostávaly tyto data jako svoje parametry konstruktoru jelikož tím pádem budou objekty méně závislé na konkrétní implementaci reprezentace vstupních dat.
\subsubsection{Vykreslování herního pole}
Dále bylo nutné se postarat o to, abych dokázal vykreslit herní pole se všemi objekty které v něm žijí. Bez toho by vůbec nemělo smysl implementovat nějaké chování objektů. Zde jsem se inspiroval kódem, který jsme využívali na cvičeních z Programování 2 při upravování hry s balvany. Rozhodl jsem se však pro větší obecnost a tudíž místo aby si informace o tom, jaké obrázky je potřeba vykreslit držela třída \textbf{Painter}, tak má každý herní objekt metodu \textbf{GetImageToDraw}, která vrátí jeho aktuální bitmapu (tedy objekt třídy \verb|Bitmap|) k vykreslení. To mi umožní, aby objekt sám mohl podle svého stavu vykreslit bitmapu kterou potřebuje a \textbf{Painter} se o to tedy vůbec nemusí starat a nemusím mít žádný \verb|switch|, který by rozhodoval, jaký objekt to je a co mám tedy vlastně vykreslit.
\subsubsection{Grafika a pohyb objektů}
Poté co jsem zprovoznil vykreslování nehybných objektů přišlo na řadu vyzkoušet. Jak si program povede s vykreslováním objektů, které se hýbou. Zde jsem v první řadě zapomněl vždy vyčistit komponentu \verb|Graphics| a tudíž se mi kreslily další vrstvy přes sebe. Nabízelo se snadné řešení: před každým dalším vykreslením všech objektů smazat celé plátno. S tím se však objevil nový problém, jelikož celá obrazovka vždy blikala. Zde mi hodně pomohla ChatGPT, která mi poradila, že to nejspíš bude tím, že program nestíhá tak rychle občerstvovat plátno a že bych měl kreslit jednotlivé obrázky do bufferu vedle a teprve až budou všechny připravené, tak výsledek překreslit do na plátno. Měla pravdu a grafika tím tedy byla úspěšně zprovozněna i pro dynamické objekty.
\subsubsection{Rozdělení projektu do více souborů}
V tomto momentu, kdy jsem se pro cokoliv co tomu alespoň trochu nahrávalo rozhodl vytvořit objekt, tak jsem měl opravdu mnoho kódu. Uvědomil jsem si, že mi dlouho zabere akorát jezdit nahoru a dolů po mém zdrojovém souboru a hledat tu správnou třídu, do které bych měl napsat nový kód nebo poupravit ten stávající. To byla veliká motivace k tomu, založit si více souborů, které by logicky odpovídaly různým částem programu. Tak jsem se tedy rozhodl pro to, mít pět hlavních zdrojových souborů. Těmi byly následující:
\begin{itemize}
    \item GameForm.cs
    \item GameManager.cs
    \item GameObjects.cs
    \item HelperClasses.cs
    \item InputManager.cs
\end{itemize}
Soubor \textbf{GameForm.cs} obsahuje kód nutný k inicializaci okénka hry a předání informací o okénku třídě \textbf{GameManager}, která žije ve vlastním stejnojmenném souboru. Tato třída se pak stará o samotnou logiku hry. Rozhoduje o tom, co se má vykreslovat na základě toho, v jakém je hra stavu, implementuje logiku herní smyčky a přijímá od Windows Forms stisknuté klávesy od uživatele, podle kterých se pak rozhoduje, co dělat, a v neposlední řadě si drží reference na všechny důležité objekty jako jsou třeba objekt \textbf{Map} nebo \textbf{Painter}. 
\\\\
Tyto dva objekty žijí ve vlastním souboru jménem \textbf{HelperClasses.cs} společně se strukturou \textbf{Direction}. To jsou v podstatě třídy, které mi neseděly do jiného souboru. V budoucnu možná ještě tyto třídy nějak logicky rozdělím. 
\\\\
Dalšími souborem je \textbf{GameObjects.cs}, který obsahuje kód všech objektů, které žijí ve hře, dají se nějak vykreslit (většinou), dá se s nimi nějak interagovat, nebo do nich narážet a nebo se samy pohybují. Tyto objekty všechny dědí od společné rodičovské třídy \textbf{Game Object}. 
\\\\
Posledním souborem, který ještě zbývá zmínit je soubor \textbf{InputManager}, který se stará o načítání a předzpracování vstupu, aby už si ho všechny objekty mohly jednoduše přečíst a nemusely se starat o nic dalšího. Rozhodl jsem se všechno obstarávání vstupu takto rozdělit také z důvodu přenositelnosti, kdybych se někdy rozhodl vstupní data reprezentovat jinak. Pak bude tedy stačit jednoduše upravit pouze tento soubor a nikde jinde nebude potřeba dělat (téměř) žádné změny.
\subsubsection{Pohyb objektů mimo mřížku}
Velikým zádrhelem, který jsem zprvu naivně úplně opomenul byl fakt, že i přesto, že hra Pac-Man se vlastně celá odehrává na 2D mřížce, tak se jednotlivé objekty jako samotný Pac-Man nebo duchové pohybují i mimo mřížku a jednotlivé buňky mřížky jim slouží pouze jako jakési křižovatky, kde občas mohou zatočit. Zde jsem nevymyslel žádné chytřejší řešení, než si spočítat velikost buňky v pixelech a dát si vždy pozor na to, aby rychlost objektu dělila tuto velikost beze zbytku. Tím jsem zaručil, že po určitém počtu snímků se mi postavička vždy objeví přesně na další buňce a můžu tedy v kódu ošetřit, co dělat dál. Jestli například sníst nějakou kuličku, nebo třeba zatočit někam jinam, či si vůbec zkontrolovat, jestli mohu pokračovat dál.
\\\\
Zde jsem využil také skryté funkčnosti, která může být pro někoho trochu překvapivá a tím je, že pokud nastavíme postavičce rychlost na nějakou, která by nevyhovovala požadavku dělitelnosti zmíněného výše, tak bude automaticky snížena na první takovou, která už bude velikost buňky dělit beze zbytku. To je trochu neintuitivní a může vést k nečekaným výsledkům, ale rozhodl jsem se tak pro to, abych mohl rychle testovat různé rychlosti a nemusel jsem vždy v hlavě počítat, jestli to zrovna bude fungovat nebo ne. Na druhou je tato redukce rychlosti provedená další pomocnou funkcí a v kódu funkce nastavující rychlost je tedy dobře tato pomocná funkce vidět. To umožňuje, abych ji kdyžtak v budoucnu mohl jednoduše najít a odstranit.
\subsubsection{Přednastavování hráčova směru}
Dále jsem chtěl naimplementovat funkčnost, která hráči umožní přednastavit, kterým směrem se hráčova postavička vydá, pokud to v aktuálním momentu není možné. Pokud tedy například stisknu šipku nahoru, tak si postavička tento směr zapamatuje a pokusí se v nejbližší možné době tímto směrem vydat. To nebylo nijak složité.
\subsubsection{Detekce kolizí s duchy}
Detekce kolizí s duchy mě trochu děsila, nevěděl jsem, jestli mi v tom skutečnost, že se jak hráč, tak i duchové pohybují mimo mřížku nezkomplikuje celý tento proces. Nakonec jsem si však uvědomil, že stačilo jednoduše zjistit, zdali x-ová a y-ová souřadnice (v pixelech) se obě liší maximálně o velikost jedné buňky. Pokud ano, tak se objekty dotýkají. V hlavní smyčce hry tedy jednoduše zavolám funkci \textbf{IsTouchingAnyGhost}, která na vstupu přijme seznam všech duchů ve hře a pokud se nějakého hráčova postavička dotýká, tak vrátí \verb|true|.
\subsubsection{Implementace tzv. „wraparound“}
Pokud se postavička pokusí opustit herní pole, tak bylo potřeba, aby se objevila přesně na druhé straně mapy. To také nebylo tak složité. Bylo však nutné hráčovy souřadnice neměnit po přetečení nebo podtečení přesně na nulu nebo maximální hodnotu, ale vždy tuto hodnotu snížit nebo zvýšit o nějaký násobek velikosti jedné buňky. To zase z toho důvodu, aby každý jeho pohyb končil přesně na nějaké buňce a při přechodu z jedné strany mapy na druhou nebyl rozsynchronizovaný tento jeho pohyb.
\subsubsection{Přidání hacku na rychlejší a ortodoxnější herní smyčku ve Winforms}
Dále mi přišlo, že hra běží na mém počítači poněkud pomalu a občas se seká, což bylo z velké části i tím, že jsem k práci s Winforms musel použít virtuální stroj k emulaci operačního systému Windows. Rozhodl jsem se tedy probádat internet, zdali někdo nemá řešení, jak program ve Winforms zrychlit. Našel jsem způsob, který využívá jakýsi hack, kdy program pokud nejsou žádné eventy od operačního systému k dispozici, tak ihned tiká a nečeká na svolení. Také je tento způsob nezávislý na tikání Winformsového timeru, který se údajně občas trochu zpožďuje a není tak přesný. Musím se však přiznat, že jsem nezaznamenal žádné očividné zlepšení avšak ani zhoršení, tak jsem se rozhodl tuto změnu ponechat. To také z toho důvodu, že nová implementace se více podobá klasické herní smyčce, která se běžně užívá v počítačových hrách.
\subsubsection{Počátky umělé inteligence duchů}
Dále jsem se rozhodl konečně uskutečnit zárodky umělé inteligence pro duchy. Tomu předcházelo, že jsem si přečetl jeden pěkný článek o tom, jak se implementovala tato umělá inteligence v originálním Pac-Manovi. Zjistil jsem, že to je jednodušší, než jsem se bál a že nebudu muset programovat prohledávání do hloubky na každé křižovatce a vystačím si jednoduše s počítáním vzdáleností. 
\\\\
Algoritmus ducha totiž spočívá v tom, že každý duch má v každém čase programu nějaký svůj cíl, na který se aktuálně snaží dostat (ten se může měnit v čase). Pro volbu, kterou cestou se vydá na příští křižovatce pak duch volí jednoduchý hladový přístup, kdy se koukne na všechny sousední políčka na křižovatce a vybere si takové sousední políčko, které je od jeho zvoleného cíle nejbližší vzdušnou čarou nehledě na skutečnou vzdálenost v dílkách pokud by šel duch po cestě. Kupodivu tento přístup celkem pěkně funguje.
\subsubsection{Stavy hry}
Abych mohl pracovat na složitějším chování duchů, tak bylo nejprve potřeba přidat základní herní stavy. Tedy počáteční obrazovku, běžící hru a konec hry. Chtěl jsem totiž mít jednoduchou možnost otestovat chování duchů a nemuset hru stále dokola spouštět manuálně přes Visual Studio. Místo toho jsem chtěl mít možnost jednoduše zmáčknout enter a hrát znovu. Dalším důvodem bylo ladění obtížnosti. To se také dělá těžko, pokud hra ještě nejde vyhrát. Takže bylo nutné tyto stavy přidat.
\\\\
Samotná implementace stavů není složitá. Uvažoval jsem, že bych použil tzv. „strategy pattern“ a využil \verb|interface| a vytvořil tzv. „state machine“. Nakonec mi toto však přišlo moc složité a zvolil jsem jednodušší způsob vytvořením výčtového typu \verb|enum|, který může nabývat hodnot různých stavů hry. Co se má dělat v jakém stavu pak kontroluji pomocí řídící struktury \verb|switch|.
\subsubsection{Módy duchů}
Jakmile jsem měl možnost přecházet mezi stavy hry, tak jsem se pustil do psaní kódu, který duchům umožní přecházet mezi čtyřmi důležitými stavy. Prvním stavem je ten, kdy je duch ještě v domečku. Dalším stavem je tzv. stav „chase“, ve kterém duch neúprosně pronásleduje hráče. Třetím stavem je tzv. „scatter“ ve kterém duch prchne na svůj vytyčený roh herního pole. Posledním důležitým stavem je stav „frightened“, ve kterém může hráč ducha sníst za dodatečné body a samotný duch se náhodně pohybuje po herním poli.
\\\\
Módy duchů jsem se rozhodl stejně jako stavy hry řešit pomocí výčtového typu \verb|enum| a \verb|switch|. To, že každý duch má v daném stavu své vlastní unikátní chování pak budu řešit pomocí dědičnosti. Udělám si pro každého ducha vlastní třídu a obecné chování ducha bude volat virtuální metodu, což umožní, aby každý duch tuto virtuální metodu „overridoval“ podle sebe.
\end{document}
