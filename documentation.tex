\documentclass[a4]{article}
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{hyperref}
\setlength{\parskip}{1em}
\setlength{\parindent}{0pt}

\hypersetup{colorlinks=true,linkcolor=black,pdftitle={Vážení kaštanů - Doprovodný dokument}}

\graphicspath{{images/}}

\title{Czech-Man
Doprovodný dokument}
\author{Autor: Jan Hartman
\\Garant: RNDr. Tomáš Holan, Ph.D.
\\Studium: bakalářské, 1. ročník, letní semestr 2022/2023
\\Předmět: Programování 2}

\date{\today}

\begin{document}
\maketitle
\tableofcontents
\pagestyle{fancy}
\newpage
\section{Úvodní část}
\subsection{Anotace}
Program Czech-Man je napodobeninou klasické hry Pac-Man z roku 1980. Neklade si za cíl být naprosto přesnou kopií hry, hlavní funkčnosti by měly být zachovány. Hra je vyvíjena v programovacím jazyce C\#.
\subsection{Formát tohoto dokumentu}
Pokud se v tomto dokumentu budu vyjadřovat k nějaké třídě nebo objektu jejím jménem, jako je v programu tak budu psát \textbf{tučně}. Jako třeba pokud zmiňuji třídu \textbf{GameManager}.

Naopak pokud zmiňuji nějaké klíčové slovo jazyka C\# nebo nějakou built-in třídu, tak budu používat formát \verb|verbatim|. Například \verb|char| nebo \verb|Bitmap|.
\subsection{Zvolené vývojové prostředí}
Prvotním úmyslem bylo hru vyvíjet ve vývojovém prostředí Unity, které je přímo určeno k vytváření počítačových her. S Unity jsem však neměl moc velké předchozí zkušenosti a po krátké snaze naučit se základy fungování tohoto prostředí jsem jeho užití zavrhl, jelikož naučit se v tomto prostředí pracovat vyžaduje mnoho specifických znalostí. Zároveň mi prostředí Unity nevyhovovalo v jeho zaměření na přesné fyzikální simulace a také fakt, že se nedá toto zaměření plně „odstínit“. Chtěl jsem pracovat v takovém prostředí, kde budu mít nad svým herním světem co největší kontrolu, a tak jsem se nakonec rozhodl pro složitější postup, který mi však umožnil mít více kontroly nad programem.

Touto volbou bylo pracovat v prostředí Windows Forms (dále už jen WinForms). To má zase nevýhodu v tom, že není primárně určeno pro tvorbu počítačových her, ale spíš k vytváření převážně statických okenních aplikací. Tím jsem se však nenechal odradit, jelikož žádné jiné prostředí podporující grafické prvky jsem neuměl používat a trvalo by mi dost času se s jakýmkoliv jiným naučit. Byla to tedy čistě pragmatická volba.
\newpage
\section{Programátorská část}
\subsection{Hlavní principy sledované při tvorbě programu}

\subsubsection{Obecnost a přenositelnost kódu do budoucna}
Při psaní kódu jsem se snažil hlavně dbát na to, aby byl program psán co nejvíce obecně a tudíž abych měl co největší prostor program do budoucna rozvíjet jakýmikoliv směry. Chtěl jsem si také nechat otevřenou možnost v budoucnu přejít na jiné vývojové prostředí než WinForms a dbal jsem tedy na to, ať je na WinForms všechna logika hry kromě samotného vykreslování co nejvíce nezávislá. Toto mě vedlo například k úplnému odstranění vizuálního designeru formy, jelikož jsem chtěl co nejvíce funkčnosti obsažené v samotném kódu, ze kterého by se v budoucnu dalo vyčíst, jak program převést do jiného prostředí lépe než z interních nastavení WinForms.

Také mě to vedlo k implementaci herní smyčky jiným způsobem než užitím třídy \verb|Timer| poskytovanou prostředí WinForms (údajně není pro herní smyčky tak přesný). Zároveň je to další prvek spojený přímo s WinForms a bylo tedy lepší ho nahradit užitím C\# třídy \verb|Stopwatch| a \verb|TimeSpan| k spočtení, jestli se má hra občerstvit. Tím jsem se zbavil další závislosti na WinForms.

\subsubsection{Objektová orientace}
Snažil jsem se také programovat co možná nejvíce objektově. Dával jsem tedy důraz na to, aby jakákoliv věc figurující ve hře byla reprezentována nějakým objektem. Zde jsem možná zaběhl do přílišných extrémů a můj kód je proto delší než by mohl být. Například tím, že jako objekty reprezentuji i prázdná políčka (což má i nějaké výhody). Upřednostňuji však často i delší kód, pokud je to za cenu lepší přehlednosti kódu. Tím, že téměř každou věc reprezentuji objektem si také otevírám dveře k tomu, abych v budoucnu mohl těmto věcem přiřadit nějaké chování, což určitě není k zahození.

\subsubsection{Čitelný kód}
Dalším principem, kterého jsem se snažil držet byl důraz na tzv. „samokomentující“ kód. To znamená, že jsem dbal velmi na to, aby jména proměnných byla co nejvíce výstižná a opravdu popisovala, co dané objekty, proměnné nebo funkce znamenají či dělají. Nebál jsem se proto klidně i delších jmen pokud mi přišlo, že by to pomohlo budoucímu čtenáři se v kódu lépe zorientovat. Zde jsem se však přistihl, že možná také zabíhám do přílišných extrémů. Během tvorby programu jsem si také uvědomil, že nemá smysl ve jménu proměnné slepě opakovat typ proměnné, ale snažit se trefným pojmenováním objektu v aktuálním kontextu přidat informační hodnotu navíc. Příkladem může být třeba příkaz: 

\verb|List<StaticLayerBlankSpace> adjacentExits = new List<StaticLayerBlankSpace>();|

Zde by nemělo smysl pojmenovávat seznam jako \textbf{adjacentBlankSpaces} jelikož fakt, že jde o prázdné políčko už vyplývá z typu proměnné.

S čitelností kódu souvisí také využití privátních metod, které jsou volány jen jednou a mohou se tedy zdát zbytečné. Mají však dle mého názoru roli podobnou, jako by měl komentář popisující celou takovou část kódu. Krásně se tím vystihne funkce daného úseku jako logického celku a umožní do budoucna třeba využít tento logický celek někde jinde v kódu. Dobrým příkladem budiž třeba metoda \textbf{SetAllGhostsToFrightenedIfPossible()} třídy \textbf{GameManager}. (Ano, je to trochu extrém.)

Snažil jsem se také chytře využít klíčová slova jako \verb|private|, \verb|public| nebo \verb|protected| k tomu, aby bylo zřejmé, jaký má daná funkce či atribut charakter tzn. jestli má být využit pouze interně a jde o jakýsi pomocný prvek nebo je to klíčový element, který slouží ke komunikaci mezi jednotlivými objekty programu. Podobným způsobem jsem oddělil data, která se mění od těch, která po dobu života objektu zůstávají neměnná klíčovým slovem \verb|readonly|. Tyto data jsem také označil jako veřejná, jelikož mi nedávalo smysl pro ně zavádět „gettery“, když stejně vrací stále to samé a nemusí se nic počítat. Dobrým příkladem jsou například atributy objektu \textbf{Map}, které souvisí s neměnnou velikostí mapy (třeba \textbf{gridWidth} nebo \textbf{cellSize}).

\subsubsection{Zapouzdření privátních dat}
V neposlední řadě jsem pak usiloval o to, aby každý objekt zpřístupňoval navenek jen ty informace, které jsou potřeba a více ne. To se vyplácí nejen z důvodu lepší čitelnosti, jak zmiňuji výše, ale také to usnadňuje práci s našeptávačem, který mi zbytečně nenabízí ty funkce, které stejně nebudu chtít na daném objektu nikdy volat.

\subsection{Chronologický postup tvorby}
Zde se pokusím popsat, jak se program postupně vyvíjel a jak na sobě jednotlivé důležité části programu časově navazují. Mám pocit, že je to užitečná informace, která slouží k lepšímu pochopení, proč jsou různé funkcionality programu řešeny tak, jak jsou řešeny a poskytne lepší přehled o tom, jaké části programu jsou závislé na kterých ostatních.

\subsubsection{Načítání vstupních dat}
Nejprve bylo nutné vůbec se rozhodnout, jak budu reprezentovat vstupní data. Rozhodl jsem se, že nejjednodušší bude zadávat herní mapu jako textový soubor, ve kterém jednotlivé symboly budou znamenat různé herní objekty. Rozhodl jsem se nejprve zadávat soubory jako Resources. (Což umožňuje Visual Studio a poskytuje možnost dané nahrané zdroje, jako třeba obrázky přímo adresovat v kódu svým jménem jako by to byla klasická proměnná) To jsem však později změnil, jelikož mi přišlo příliš krkolomné přidávat takto nové obrázky. (Bylo potřeba otevřít soubor s příponou .resx a proklikat se několika volbami.) Je jednodušší mít jednu složku, ze které akorát přečtu soubor s daným jménem, které zadám do proměnné jako \verb|string|.

Jinak jsem se snažil vstupní data co nejvíce oddělit od zbytku programu a založil jsem tedy samostatnou statickou třídu \textbf{GamePresets}, která se stará o vše týkající se načítání a předzpracování vstupních dat. Tím je myšleno například vytvoření hotového objektu \textbf{Map} z přečteného souboru \textbf{map.txt}, který obsahuje textové zadání herního plánku. Nebo třeba vytvoření objektů typu \verb|Bitmap|, které pak předávám jednotlivým instancím třídy \textbf{GameObject} jako jejich obrazové reprezentace (neboli „sprity“).

V prvotních fázích programu si objekty tyto svoje interní informace načítaly přímo od třídy \textbf{GamePresets}, ale toto „šahání jiné třídě do zelí“ se mi později znelíbilo a zvolil jsem raději předávání těchto informací jako parametry konstruktoru. To byl také případ objektu \textbf{Map}, jehož seznam parametrů však na druhou stranu touto úpravou nabobtnal na dobrých devět prvků!

To, že si později každý objekt pamatoval všechna data jenž se ho týkala, vedlo i k tomu, že jsem nemusel ve třídě \textbf{Painter} provádět složité kontrolování toho, jaký objekt se to vlastně teď snažím nakreslit pomocí \verb|if|ů, jak popisuji v následující sekci.

\subsubsection{Základní grafika} \label{staticgraphics}
Dále bylo nutné se postarat o to, abych dokázal vykreslit herní pole se všemi objekty které v něm žijí. Bez toho by vůbec nemělo smysl implementovat nějaké chování objektů. Zde jsem se inspiroval kódem, který jsme využívali na cvičeních z Programování 2. (konkrétně při modifikaci hry s padajícími balvany a diamanty) a nejprve jsem tedy kreslení různých objektů rozhodoval přímo ve třídě \textbf{Painter}, která obsahovala také všechny možné obrázky jednotlivých objektů. Když pak bylo potřeba nějaký objekt vykreslit, tak jsem se zeptal na jeho typ a dle toho jsem vykreslil odpovídající bitmapu. To však vedlo k nutnosti mít v kódu přehršel \textbf{if}ů a celé to bylo velmi nepřehledné

Rozhodl jsem se tedy později pro větší obecnost a tudíž místo aby si informace o tom, jaké obrázky je potřeba vykreslit držela třída \textbf{Painter}, tak má každý herní objekt metodu \textbf{GetImageToDraw()}, která vrátí jeho aktuální bitmapu (tedy objekt třídy \verb|Bitmap|) k vykreslení. To mi umožní, aby objekt sám mohl podle svého stavu vykreslit bitmapu kterou potřebuje a \textbf{Painter} se o to tedy vůbec nemusí starat a nemusím mít žádný \verb|switch|, který by rozhodoval, jaký objekt to je a co mám tedy vlastně vykreslit. To se mi konkrétně hodilo při vykreslování duchů v závislosti na jejich aktuálním módu (více o módech v sekci \ref{generalmodes}). Pokud duchové byli vyděšení a měli prchat (viz. \ref{frightenedmode}), tak stačilo přepsat rodičovskou metodu \textbf{GetImageToDraw()} a rozhodnout se, jakou bitmapu vrátit na základě aktuálního nastaveného módu (\textbf{currentMode}).

\subsubsection{Vykreslování pohybujících se objektů} \label{buffering}
Poté co jsem zprovoznil vykreslování nehybných objektů přišlo na řadu vyzkoušet, jak si program povede s vykreslováním pohybujících se objektů. Zde jsem v první řadě zapomněl vždy vyčistit komponentu \verb|Graphics| a tudíž se mi kreslily další vrstvy přes sebe. Nabízelo se snadné řešení: Před každým dalším vykreslením všech objektů smazat celé plátno. S tím se však objevil nový problém, jelikož celá obrazovka při každém přepsání blikala. Zde mi hodně pomohla ChatGPT, která mi poradila, že to nejspíš bude tím, že program nestíhá tak rychle občerstvovat plátno a že bych měl kreslit jednotlivé obrázky do bufferu (reprezentován objekty \textbf{bufferBitmap} a \textbf{bufferGraphics}) teprve až budou všechny připravené, tak výsledek překreslit na plátno. (K tomu slouží příkaz \verb|formGraphics.DrawImageUnscaled(bufferBitmap,0,0)|, kde \textbf{formGraphics} je \verb|Graphics| komponenta našeho herního okénka vytvořená příkazem \verb|CreateGraphics()|.) O vyčištění bufferu před dalším malováním se stará funkce \textbf{ClearBuffer()} a o překopírování bufferu do herního okénka pak \textbf{WriteBuffer()}.

\subsubsection{Rozdělení projektu do více souborů}
V tomto momentu, kdy jsem se pro cokoliv, co tomu alespoň trochu nahrávalo rozhodl vytvořit objekt už jsem měl opravdu mnoho kódu. Uvědomil jsem si, že mi poměrně dlouho zabere samotné ježdění nahoru a dolu po mém zdrojovém souboru a hledání té správné třídy, jejíž kód jsem zrovna potřeboval upravit. To byla veliká motivace k tomu, založit si pro můj projekt více souborů, které by logicky odpovídaly různým částem programu. Tak jsem se tedy rozhodl pro to, mít pět hlavních zdrojových souborů. Těmi byly následující:
\begin{itemize}
    \item \textbf{GameForm.cs}
    \item \textbf{GameManager.cs}
    \item \textbf{GameObjects.cs}
    \item \textbf{HelperClasses.cs}
    \item \textbf{InputManager.cs}
\end{itemize}
Soubor \textbf{GameForm.cs} obsahuje kód nutný k inicializaci okénka hry a předání informací o okénku třídě \textbf{GameManager}, která žije ve vlastním stejnojmenném souboru. Tato třída se pak stará o samotnou logiku hry. Rozhoduje o tom, co se má vykreslovat na základě toho, v jakém je hra stavu, implementuje logiku herní smyčky a přijímá od Windows Forms stisknuté klávesy od uživatele, podle kterých se pak rozhoduje, co dělat. V neposlední řadě si třída \textbf{GameManager} drží reference na dva pro běh hry klíčové objekty \textbf{Map} a \textbf{Painter}.

Tyto dva objekty žijí ve vlastním souboru jménem \textbf{HelperClasses.cs} společně se strukturou \textbf{Direction}. To jsou v podstatě třídy, které mi neseděly do jiného souboru. V budoucnu možná ještě tyto třídy nějak logicky rozdělím. 

Dalšími souborem je \textbf{GameObjects.cs}, který obsahuje kód všech objektů, které žijí ve hře, dají se nějak vykreslit (většinou), dá se s nimi nějak interagovat, nebo do nich narážet a nebo se samy pohybují. Tyto objekty všechny dědí od společné rodičovské třídy \textbf{Game Object}. Ta poskytuje abstrakci nad všemi objekty a vynucuje si například, aby obsahovaly implementaci metod \textbf{GetGridX()} a \textbf{GetGridY()}, které slouží k vrácení aktuální souřadnic v mřížce (a to i pokud se objekt zrovna pohybuje mezi dvěmi buňkami mřížky!). Také si vynucuje, aby každý objekt o sobě uměl říci, jestli je vykreslitelný (metoda \textbf{IsDrawable()}) nebo aby uměl vrátit svou bitmapu, jak jsem již zmiňoval.

Posledním souborem, který ještě zbývá zmínit je soubor \textbf{GamePresets}, který se stará o předvolby programu jako jsou třeba rychlost hráče, velikost jedné buňky herního pole, nebo samotné čtení zadání herní mapy ze souboru \textbf{map.txt} či čtení obrázků ze souborů ve formátu PNG. Stará se tedy o předzpracování tohoto vstupu, aby si ho všechny objekty mohly jednoduše přečíst a nemusely se starat o nic dalšího. Tímto rozdělením se dá snadno všechny předvolby programu nastavovat pěkně na jednom místě a není třeba prohledávat kódy jednotlivých tříd.

Druhým důvodem pro vytvoření vlastní třídy pro veškeré obstarávání vstupu (téměř veškeré až na přednastavení textu a ostatních věcí souvisejících více s WindowsForms než s mechanikou hry), kdybych se někdy rozhodl vstupní data načítat jiným způsobem. Pak bude stačit jednoduše upravit pouze tento soubor a nikde jinde nebude potřeba dělat skoro žádné změny.

\subsubsection{Pohyb objektů mimo mřížku} \label{tweening}
Velikým zádrhelem, který jsem zprvu naivně úplně opomenul byl fakt, že i přesto, že hra Pac-Man se vlastně celá odehrává na 2D mřížce, tak se jednotlivé objekty, jako samotný Pac-Man nebo duchové pohybují i mimo mřížku a jednotlivé buňky mřížky jim slouží pouze jako jakési „křižovatky“, kde občas mohou zatočit. Zde jsem nevymyslel žádné chytřejší řešení, než si spočítat velikost buňky v pixelech a dát si vždy pozor na to, aby rychlost objektu dělila tuto velikost beze zbytku. (Třída, od které objekty mající tuto vlastnost dědí se jmenuje \textbf{TweeningObject}.) Tím jsem zaručil, že po určitém počtu snímků se mi postavička vždy objeví přesně na další buňce a můžu tedy v kódu ošetřit, co dělat dál. Jestli například sníst nějakou kuličku (\textbf{Pellet}), nebo třeba zatočit někam jinam, či si vůbec zkontrolovat, jestli mohu pokračovat dál (\textbf{CanGoInDirection()}).

Zde jsem využil také skryté funkčnosti, která může být pro někoho trochu překvapivá a tím je, že pokud nastavíme postavičce rychlost na nějakou, která by nevyhovovala požadavku dělitelnosti zmíněného výše, tak bude automaticky snížena na první takovou, která už bude velikost buňky dělit beze zbytku. To může být trochu překvapující (až matoucí), ale rozhodl jsem se tak pro to, abych mohl rychle testovat různé rychlosti a nemusel jsem vždy v hlavě počítat, jestli to zrovna bude fungovat nebo ne. Konkrétně se o tuto funkčnost stará metoda \textbf{SetTweenSpeed()}. 

Na druhou je tato redukce rychlosti provedená další pomocnou funkcí \textbf{ReduceToDivisibleWithoutRemainder()} a v kódu volající funkce je tedy dobře tato volaná funkce vidět. To mi umožňuje, abych ji pokud to bude nutné mohl v budoucnu jednoduše najít a odstranit.

\subsubsection{Přednastavování hráčova směru}
Dále jsem chtěl naimplementovat herní mechaniku, která hráči umožní přednastavit, kterým směrem se hráčova postavička vydá příště, i když to zrovna není možné. Pokud tedy například stisknu šipku nahoru, tak si postavička tento směr zapamatuje a pokusí se v nejbližší možné době tímto směrem vydat. To však nebylo nijak složité. Stačilo přidat atribut \textbf{nextDirection}, který umožňuje si daný směr do příště zapamatovat a využít to pokud možno při testování, kudy by se měla postavička z aktuální buňky pohnout dále. (To se děje uvnitř metody \textbf{StartNextMovementCycle()}.)

\subsubsection{Směry obecně} \label{directions}
Bylo by v tomto momentu dobré zmínit, jak se tento směr v programu reprezentuje. Rozhodl jsem se pro vytvoření vlastní struktury jménem \textbf{Direction}, která má dvě datové položky \textbf{X} a \textbf{Y}, reprezentující jednotlivé složky dvou dimenzionálního vektoru. Dohodou se sebou samým jsem si stanovil, že takovému vektoru budu přiřazovat pouze pět možných hodnot, tedy vektory jednotkové délky do čtyř světových stran a nulový vektor. Využil jsem také možnosti zavádět \verb|properties| k tomu, abych například voláním \textbf{Direction.Left} mohl získat referenci na vektor (-1,0).

Každý pohybující objekt tedy musí obsahovat atribut \textbf{direction}, který se pak využívá k určení, kterým směrem bude pokračovat v pohybu a o kolik se má přesně pohnout. (Konkrétně se tento výpočet provádí v metodě \textbf{ContinueMoving()} objektu \textbf{TweeningObject}.) Atribut \textbf{direction} objektu \textbf{Hero} se také hojně využívá při nastavování cílů duchů, jak popisuji v sekci \ref{concretemodes}.

\subsubsection{Detekce kolizí s duchy} \label{collisiondetection}
Implementace detekce kolizí s duchy mě trochu děsila. Nevěděl jsem, zdali mi v tom skutečnost, že se jak hráč, tak i duchové pohybují mimo mřížku nebude dělat paseku. Nakonec jsem si však uvědomil, že stačilo jednoduše zjistit, zdali se jak x-ová, tak y-ová souřadnice (v pixelech!) obě liší maximálně o velikost jedné buňky. Pokud ano, tak se objekty dotýkají, jinak ne. Tento výpočet provádí funkce \textbf{IsTouchingTweeningObject()}. V hlavní smyčce hry tedy jednoduše zavolám funkci \textbf{IsTouchingAnyGhost}(), která na vstupu přijme seznam všech duchů ve hře a pomocí výše zmíněné funkce otestuje, jestli se některého z nich hráč dotýká nebo ne.

\subsubsection{Implementace tzv. „wraparound“ a problémy s tím spojené} \label{wraparound}
Pokud se postavička pokusí opustit herní pole, tak bylo potřeba, aby se objevila přesně na druhé straně mapy. To nebylo pro pohyb hráče tak složité. Bylo však nutné hráčovy souřadnice slepě neměnit po přetečení nebo podtečení přesně na nulu nebo maximální hodnotu, ale vždy tuto hodnotu snížit nebo zvýšit o nějaký násobek velikosti jedné buňky. Jinak by se totiž mohlo stát, že by postavička ukončila jeden svůj cyklus pohybu mimo střed nějaké buňky. To by mohlo mít za následek, že by pak postavička skončila pohyb uvnitř zdi nebo jinou podobnou prekérní situaci. O toto „zaobalování“ souřadnic se stará funkce \textbf{GetWrappedPixelLocation()}, kterou poskytuje třída \textbf{Map}.

Toto fungovalo nějakou dobu uspokojivě, ale později se ukázalo, že duchové, kteří pro své fungování potřebují znát mřížkovou lokaci poslední navštívené buňky při přechodu na druhý okraj mapy neregistrovaly krajní políčka mapy. To vedlo k tomu, že si mysleli, že toto políčko ještě nenavštívili a vraceli se zpět. Toto jsem bohužel musel opravit jako speciální případ (nenašel jsem lepší způsob) a řeším ho v metodě \textbf{WraparoundIfOutOfBounds()} zavoláním metody \textbf{UpdateLastOccupied()}, kterou bych ve standardním případě volal jen před začátkem dalšího cyklu pohybu mezi dvěmi sousedními buňkami.

Aby toho nebylo málo, tak se objevil další nečekaný zádrhel. Duchové totiž při hledání cesty, kterou se mají bludištěm navigovat kontrolují sousední políčka a koukají se, která z nich jsou prázdná. Co když jsou však duchové na kraji mapy? Nabízí se jednoduše „zaobalit“ souřadnici souseda při kontrole všech sousedních políček abychom získali políčko, které je sice na druhé straně mapy, ale prakticky je sousední. Zde jsem však zkolaboval na předpokladu, že poté co si duch zvolí sousední políčko na které bude pokračovat, stačí odečíst jeho aktuální pozici od pozici souseda a získám tím požadovaný vektor příštího pohybu. Výsledkem byl duch, jehož vektor \textbf{direction} (To je proměnná typu \textbf{Direction} viz \ref{directions}) měl místo klasické jednotkové délky délku rovnou velikosti mapy (tedy buď šířky nebo délky). Hodnota privátní proměnné \textbf{direction} se však využívá uvnitř těla metody \textbf{ContinueMoving()} objektu \textbf{TweeningObject} k výpočtu toho, o kolik pixelů se v daném snímku hry má duch posunout. Tak se stalo, že mi duchové lítali z jedné strany mapy na druhou bleskovou rychlostí dokud je nezastavila zákeřná \verb|IndexOutOfBoundsException|. Řešením byl bohužel již druhý speciální případ, který jsem musel umístit dovnitř metody \textbf{SetDirectionTowardsExit()}, kterou poskytuje třída \textbf{MovingObject}. Konkrétně dle toho, kterým směrem se vektor protáhl, lze určit správný směr, kterým by se měl duch vydat. Toť směr k tomuto přerostlému směru přesně opačný avšak jednotkové délky. Toto jednoduché řešení poskytuje privátní metoda \textbf{GetFixedOutOfBoundsCoordinate()}, která upraví zvlášť každou složku takto zdivočelého vektoru.

\subsubsection{Přidání hacku na rychlejší a ortodoxnější herní smyčku ve WinForms} \label{gameloophack}
Dále jsem měl pocit, že hra běží na mém počítači poněkud pomalu a občas se zadrhává, což bylo z velké části nějspíš i tím, že jsem k práci s WinForms musel použít virtuální stroj k emulaci operačního systému Windows. Rozhodl jsem se tedy probádat internet, zdali někdo nemá řešení, jak program ve WinForms zrychlit. 

Našel jsem způsob, který využívá jakýsi hack, kdy program nečeká, dokud se nespustí nějaký jeho event, ale namísto toho běží neustále, dokud je tzv. „windows message queue“ prázdná. Tento způsob je kromě (údajné) vyšší rychlosti a přesnosti herní smyčky nezávislý na tikání WinFormsového timeru (objekt typu \verb|Timer|), který se údajně občas trochu zpožďuje a není tak přesný. 

Musím se však přiznat, že jsem nezaznamenal žádné očividné zlepšení avšak ani zhoršení. Rozhodl jsem se tedy tuto změnu v programu ponechat. Částečně také z toho důvodu, že nová implementace se více podobá klasické herní smyčce, která se běžně užívá v počítačových hrách a navíc je závislá na objektu typu \verb|Stopwatch|, který by měl poskytovat to zmíněné pravidelnější tikání.

\subsubsection{Duchovský pathfinding} \label{ghostpathfinding}
Dále jsem se rozhodl konečně uskutečnit zárodky umělé inteligence duchů. Tomu předcházelo, že jsem si přečetl jeden \href{https://www.gamedeveloper.com/design/the-pac-man-dossier}{pěkný článek} o tom, jak se implementovala tato umělá inteligence v originálním Pac-Manovi. Zjistil jsem, že jádro chování jednotlivých duchů je výpočetně jednodušší, než jsem se původně bál a nebudu tedy muset programovat žádné prohledávání do šířky na každé křižovatce a vystačím si jednoduše s počítáním vzdáleností. 

Algoritmus hledání cesty bludištěm totiž spočívá v tom, že každý duch má v každém čase programu nějaký svůj cíl (v programu ho reprezentuji proměnnou \textbf{target} typu \verb|Point|), na který se aktuálně snaží dostat (jeho poloha se neustále mění v čase). Pro volbu, kterou cestou se vydá na příští křižovatce pak duch volí jednoduchý hladový přístup, který spočívá v tom, že se koukne na všechna sousední políčka na křižovatce (Referenci na ně získá zavoláním metody \textbf{GetAdjacentBlankCells()} objektu \textbf{Map}.) a vybere si takové sousední políčko, které je od jím zvoleného cíle (\textbf{target}u) nejblíže vzdušnou čarou. A to nehledě na skutečný počet buněk, které bude muset duch při pronásledování svého cíle překonat. O toto nalezení nejbližšího sousedního políčka se stará metoda \textbf{FindExitClosestToTarget()}, která ve svém těle volá pomocnou funkci \textbf{GetDistanceToCell()}, aby určila jednotlivé vzdálenosti. Kupodivu tento přístup celkem pěkně funguje (pokud předpokládáme klasickou Pac-Manovskou herní mapu).

Ještě by bylo příhodné dodat, že duch si nikdy nevybírá východ z křižovatky, ze kterého právě přišel (což se dá hezky využít i v situaci, kdy jsou východy právě dva). Kvůli tomu potřebujeme zavést pomocný atribut \textbf{LastOccupiedCell}, díky kterému si duch pamatuje, jakou buňku posledně navštívit. Tento atribut je umístěn v objektu \textbf{TweeningObject} (viz sekce \ref{tweening}), i když původně se nacházel přímo v objektu \textbf{Ghost}. K této změně mě donutil právě problém se „zaobalováním“ souřadnic zmíněný v třetím odstavci sekce \ref{wraparound}.

\subsubsection{Stavy hry} \label{gamestates}
Abych mohl pracovat na složitějším chování duchů, tak bylo nejprve potřeba přidat základní herní stavy. Tedy počáteční obrazovku, běžící hru a konec hry. Chtěl jsem totiž mít jednoduchou možnost otestovat chování duchů a nemuset hru stále dokola spouštět manuálně přes Visual Studio. Místo toho jsem chtěl mít možnost jednoduše zmáčknout „enter” a hrát znovu. Dalším důvodem bylo ladění obtížnosti. To se také dělá těžko, pokud hra ještě nejde vyhrát. Takže bylo nutné tyto stavy přidat.

Samotná implementace stavů není složitá. Uvažoval jsem, že bych použil tzv. „strategy pattern“ a využil \verb|interface| a vytvořil tzv. „state machine“. Nakonec mi toto však přišlo moc složité a zvolil jsem jednodušší způsob vytvořením výčtového typu \textbf{GameState}, který může nabývat hodnot různých stavů hry (tedy \textbf{StartSceen}, \textbf{Running} a \textbf{GameOverScreen}). Co se má dělat v jakém stavu pak kontroluji pomocí řídící struktury \verb|switch| uvnitř veřejné metody \textbf{Update()}, která je volána z hlavní herní smyčky implementované uvnitř kódu třídy \textbf{GameForm}. 

Stav \textbf{GameOverScreen} odpovídá jak vítězné obrazovce, tak i té poražené. Zde jsem uvažoval tyto dvě možnosti rozdělit do dvou separátních stavů, ale nakonec jsem se rozhodl přidat boolovskou proměnnou \textbf{gameLost}, která určuje, která ze dvou obrazovek se má vypsat.

Ze stavu \textbf{Running} do stavu \textbf{GameOverScreen} lze přejít dvěma způsoby. Buď hráče chytil duch, což kontroluje metoda \textbf{CheckGhostCollisions()} nebo hráč snědl všechny interaktivní objekty \textbf{Pellet}s a \textbf{Energizer}s a to zas kontroluje metoda \textbf{CheckGameWon()}.

\subsubsection{Módy duchů} \label{generalmodes}
Jakmile jsem měl možnost přecházet mezi stavy hry, tak jsem se pustil do psaní kódu, který duchům umožní přecházet mezi čtyřmi důležitými módy, což jsou vlastně jejich způsoby chování. Tyto módy jsem chtěl naipmlementovat v této fázi programu, jelikož na nich závisí, jakým způsobem si jednotliví duchové vybírají svůj cíl. Abych tedy mohl naprogramovat složitější chování duchů, tak bylo příhodné mít možnost mezi těmito módy nějak přecházet.

Módy jsou reprezentovány dalším výčtovým typem jménem \textbf{GhostMode} a nabývá hodnot \textbf{Preparing}, \textbf{Chase}, \textbf{Scatter} a \textbf{Frightened}. Každý duch má interně uložený svůj aktuální mód, ve kterém se nachází v privátní proměnné \textbf{currentMode}. Zároveň, jelikož mezi módy \textbf{Chase}, \textbf{Scatter} a \textbf{Frightened} se duchové přepínají po signálu ze vnějšku, tak reprezentuji také jakýsi globální mód uvnitř objektu \textbf{GameManager}, který určuje, ve kterém stavu se duchové právě nachází (pokud zrovna nejsou v domečku ve stavu \textbf{Preparing}, potom je jejich mód na tom globálním nezávislý). Tento globální mód je uložen v proměnné \textbf{currentGhostMode}.

\subsubsection{Obecný význam jednotlivých módů} \label{modemeaning}
Nyní bych chtěl krátce uvést, co módy duchů reprezentují obecně a později bych se věnoval tomu, jak jsou naimplementované každým duchem zvlášť. To je totiž unikátní vlastnost hry Pac-Man, že každý duch má svůj charakter a chová se tedy trochu jinak, než ti ostatní. Jedinou výjimkou je mód \textbf{Frightened}, ve kterém se všichni duchové chovají úplně stejně.

Prvním módem duchů v mé implementaci hry je mód \textbf{Preparing}, kterému v originálním Pac-Manovi však žádný mód neodpovídá. Chtěl jsem tímto módem reprezentovat stav, kdy je duch ještě v domečku a čeká, až ho bude moci opustit. Domeček je totiž ohrazen objekty typu \textbf{Fence}, které jsou pro ducha nejprve neprostupné a po uplynutí času (ten si duch interně pamatuje v proměnné \textbf{prepareDuration}) mu je umožněno domeček opustit. Duchovi se v závislosti na jeho módu a na tom, jestli už opustil domeček (to zas kontroluje boolovská proměnná \textbf{leftHouse} musí měnit skutečnost, zdali je pro něj plot dosažitelný nebo ne. To je zajištěno přepsáním metody \textbf{IsReachableCell()} rodičovské třídy \textbf{GameObject}.

Druhým módem je mód \textbf{Chase}, ve kterém se každý duch chová velmi jinak. Detaily popíši v sekci \ref{concretemodes}. Obecně to však znamená, že duch nějakým svým vlastním způsobem zvolí cíl tak, aby nějak zkřížil hráči cestu. Většinou si tedy volí svůj \textbf{target} (viz sekce \ref{ghostpathfinding}) nějak v závislosti na poloze hráče. V těle třídy \textbf{Ghost} je vyhrazena metoda \textbf{SetTargetToChaseTarget()}, která je abstraktní a je určená k tomu, aby si ji každý konkrétní duch přepsal dle své potřeby.

Třetím módem je mód \textbf{Scatter}, který je implementován velmi jednoduše. Jde o to, že duch si nastaví svůj cíl do nějakého rohu mapy, což má za následek to, že duch pak v tomto rohu mapy krouží pořád dokola. Stejně jako je tomu u předchozího módu má třída \textbf{Ghost} pro jednotlivé duchy vyhrazenou abstraktní metodu \textbf{SetTargetToScatterTarget()}.

Posledním avšak neméně důležitým a zajímavým módem je mód \textbf{Frightened}. Do tohoto módu se duchové nepřepínají v závislosti na čase, jako je tomu u zbylých módu, ale v závislosti na tom, zda-li hráč sní power-up reprezentovaný objektem typu \textbf{Energizer}. To se kontroluje v metodě \textbf{TryEat()}, která volána z hlavní herní smyčky pokud se hra nachází ve stavu \textbf{Running}. Pokud hráč \textbf{Energizer} sní, tak se hra všem duchům tento mód pokusí nastavit zavoláním metody \textbf{SetAllGhostsToFrightenedIfPossible()}, která se nachází právě uvnitř těla metody \textbf{TryEat()}. Metoda \textbf{SetAllGhostsFrightenedIfPossible()} projde seznamem všech duchů ve hře a zavolá na nich metodu \textbf{SetModeIfValid()} s parametrem \textbf{GhostMode.Frightened}. Tato metoda se pak postará o to, aby se duch nenastavoval do módu \textbf{Frightened} pokud je například stále ještě v domečku. (Pozor! Pokud je v domečku, ale zrovna přešel do jiného módu a chystá se opustit domeček, tak se stejné může vyděsit a zmodrat.)

V módu \textbf{Frightened} všichni duchové zmodrají a pohybují se po herní mapě náhodně (na každé křižovatce si zvolí náhodnou pozici \textbf{target}u. Hráči je umožněno v tomto módu duchy sníst a získat za ně bodový bonus. Poté, co je nějaký duch sněden, tak se objeví zpět na svém domovském políčku a je nastaven zpět do módu \textbf{Preparing} s časovačem nastaveným zpět na nulu.

\subsubsection{Konkrétní implementace módů konkrétními duchy} \label{concretemodes}
Charaktery jednotlivých duchů v módech \textbf{Scatter} a \textbf{Chase} jsem se rozhodl řešit tím, že jsem pro každého ducha zavedl jeho vlastní třídu. Při volání metod na nastavení cíle v daném módu je pak využito polymorfizmu díky tomu, že každý z konkrétních duchů dědí od třídy \textbf{Ghost}. Třídy jednotlivých duchů jsou postupně \textbf{RedGhost}, \textbf{PinkGhost}, \textbf{BlueGhost} a \textbf{OrangeGhost}. 

\textbf{RedGhost} byl na implementaci vůbec nejjednodušší. Jeho způsob výběru cíle v módu \textbf{Chase} je takový, že ho na každé křižovatce umístí vždy přesně na hráče. Dále pak použije hladový způsob hledání cesty ze sekce \ref{ghostpathfinding}. Umístění \textbf{target}u přímo na hráče obstarává metoda \textbf{SetTargetAheadOfHero()} zavolaná s argumentem 0 pro parametr \textbf{tilesAhead}, který udává, o kolik políček před hráčem si má duch nastavit svůj \textbf{target}. Touto obecnou metodou jsem si zkrátil kód, jelikož ji pak mohu využít i pro ostatní duchy. (Popravdě ji nějak využívá v módu \textbf{Chase} každý z nich.) V módu \textbf{Scatter} chodí v pravém horním rohu.

\textbf{PinkGhost} má velmi podobný algoritmus jako předchozí duch s jediným rozdílem, že místo toho, aby \textbf{target} umístil přesně na hráče, tak ho umísťuje přesně čtyři políčka v jeho aktuálním směru před něj. V módu \textbf{Scatter} si pak cíl nastavuje do levého horního rohu.

\textbf{BlueGhost} má ze všech duchů vůbec nejsložitější a nejméně předvídatelné chování. V módu \textbf{Chase} si nejprve nastaví cíl dvě políčka před hráče a poté se koukne, kde je \textbf{RedGhost} a posune své cílové políčko přesně o vzdálenost mezi \textbf{RedGhost}em a nově nastaveným cílem ve stejném směru. Během módu \textbf{Scatter} krouží v pravém dolním rohu.

\textbf{OrangeGhost} posledním z duchů je duch oranžový, který má také poměrně zvláštní chování. V módu \textbf{Chase} se rozhoduje podle vzdálenosti od hráče. Pokud je o hráče vzdálen o méně než osm políček, tak se snaží prchnout do svého rohu, který je pro něj stejný jako během módu \textbf{Scatter}. Naopak pokud je od hráče dále, tak si nastavuje \textbf{target} přímo na hráče stejným způsobem, jako to dělá první z duchů. Pro zjišťování vzdálenosti od hráče využívá metody \textbf{GetDistanceToCell()}, kterou zmiňuji v sekci \ref{ghostpathfinding} ve druhém odstavci.

\subsubsection{Časování globálních módů duchů} \label{globalmodetiming}
Jak jsem již zmínil tak mezi některými módy je nutné přepínat v závislosti na čase nebo jiných podmínkách globálně, aby byli všichni duchové co možná nejvíce synchronizovaní. Nyní, když už jsem měl zhotovené konkrétní chování pro jednotlivé duchy, tak jsem mohl toto časování pěkně testovat. Jelikož toto přepínání je řízeno samotnou hrou, bylo mi hned jasné, že bude potřeba upravit kód třídy \textbf{GameManager}. Konkrétně bylo nutné přidat této třídě časovač, kterými by mohla zkoumat, kolik času uběhlo od poslední globální změny duchovského módu. Tento čas je uložen jako atribut \textbf{lastModeChange} typu \verb|DateTime|. O případnou změnu módu pokud nastane čas se stará metoda \textbf{ChangeModeIfTime()}, která pomocí \textbf{switch}e přes aktuální globální mód duchů (\textbf{currentGhostMode}) rozhodne, jaký časový interval má zrovna testovat testuje se vždy jeden z \textbf{scatterModeDuration}, \textbf{chaseModeDuration} nebo \textbf{frightenedModeDuration}, které jsou všechny typu \verb|TimeSpan|. 

\subsubsection{Implementace zmodrání duchů ve frightened módu} \label{frightenedmode}
Hra po dokončení předchozí fáze již pěkně fungovala. Samozřejmě jsem ještě opomenul počítání skóre, avšak to bylo tak triviální, že by bylo zbytečné mu věnovat samostatnou sekci. Zbývalo tedy už jen způsobit, aby duchové pokud jsou v módu \textbf{Frightened} přeměnili svůj obrázek na modrý, čímž hráči jasně signalizují, že se dají sníst. 

Rozhodl jsem se vyřešit toto chování tím, že jsem do třídy \textbf{Ghost} přidal navíc atribut typu \textbf{Bitmap}, který duchům umožní držet si odkaz na modrý obrázek, který pak v případě zavolání metody \textbf{GetImageToDraw()} vrátí místo svého klasického pokud jsou právě v módu \textbf{Frightened}. Zbytek pak delegují na \textbf{Painter} která je popsána blíže v sekci \ref{staticgraphics}.

\subsection{Poslední kosmetické úpravy a komentování kódu}
V této fázi už byla hra hratelná a tedy hotová. Rád bych samozřejmě přidal ještě třeba možnost více životů hráče, nebo další úrovně či animování postaviček, ale bohužel mě již tlačil čas (a stále tlačí i během psaní této dokumentace). 

I přesto jsem však věnoval vlastně jeden celý den komentování kódu, přejmenovávání a dalšího. Tolik času mi to trvalo i z toho důvodu, že pokud já začnu svůj kód komentovat, tak to má za následky, že zpozoruji, co vše by se dalo napsat lépe a nakonec třeba ještě nějaký kód pozměním. Výsledkem však je čitelnější a občas i optimalizovanější kód. 

Takto jsem například už hotové hře přepsal tělo metody \textbf{StartNextMovementCycle()} tak, aby byla přehlednější. Původně jsem se spokojil s tím, že to „nějak fungovalo“ a přehlednost jsem tolik neřešil (čímž jsem porušil svůj zmiňovaný princip, ale jak říkám, už mě začal tlačit čas a chtěl jsem vidět rychlé výsledky). Když jsem však začal tuto metodu komentovat, tak jsem si uvědomil, že i pro mě to je celkem „blackbox“ a vlastně ji částečně zprovoznil metodou pokus omyl. Během její analýzy jsem narazil na chybu, při které se duchové v případě, že zašli do slepé uličky (což se na klasickém herním poli hry Pac-Man nemůže stát), tak pokračovali dále a procházeli zdí. Tento bug jsem rychle opravil a do budoucna je moje hra robustnější, pokud bych se rozhodl nějak upravovat herní mapu.

\section{Závěr}
\subsection{Co by se dalo vylepšit}
\subsubsection{Životy hráče}
Jak jsem již zmínil, tak by bylo hezké. Kdybych do hry naimplementoval ubírání životů hráče. To by nemělo být příliš složité. Potřeboval bych přidat funkci, která by resetovala duchy na své místo v domečku a všechny časovače, ale zároveň ponechala všechny objekty, které může hráč sníst a ještě mu zbývají na herním poli. Také by bylo nutné buď přidat stav, ve kterém hra dává chvilku času hráči se rozkoukat pokud byl zrovna polapen. Tento čas by se také dal zavést přímo do stavu \textbf{Running} přidáním podmínky.

\subsubsection{Přidání dalších levelů a počítání highscore}
Aby hra byla trochu kompetitivnější, tak by se hodilo přidat jak další levely, ve kterých by se duchové například mohli zrychlovat, tak i přidat pamatování highscore. Přidat další levely by mohlo být časově celkem náročné. Nevím, jak přesně bych naipmlementoval různé zvětšování rychlostí duchů a ztěžování obtížnosti hry. Přidat highscore by však naopak složité nebylo. Stačilo by zavést nový textový soubor, do kterého bych si toto highscore ukládal a nebo z něj četl.

\subsubsection{Animace otevírání pusy hráče a očí duchů}
Dalším vylepšením by mohlo být přidat animace pohybujících se postaviček. Zde by se dalo například poskytnout každému objektu namísto jedné bitmapy (nebo dvou) celé pole bitmap. Podle svého aktuálního směru by se pak postavička rozhodla, jakou bitmapu má při zavolání metody \textbf{GetImageToDraw()} vrátit.

U otevírání pusy hráče by pak chtělo ještě přidat nějaký časovač objektu \textbf{Hero}, který by umožnil volit snímky také v závislosti na aktuálním čase.

Uvažoval jsem také, že by nebylo nutné přidávat pro různé směry otočení hráče nové snímky, ale po krátké analýze jsem zjistil, že otáčet bitmapy v C\# je poměrně náročný proces.

\subsection{Závěrečný povzdech}
Tvorba této hry pro mě byla něčím úplně novým. Sám moc počítačové hry nehraji, ale dostal jsem chuť konečně vytvořit nějaký grafický interaktivní program, čehož je počítačová hra dobrým příkladem. Nakonec bylo vtipné si uvědomit, že se mi občas hodily poznatky z kroužku tvorby počítačových her ve Scratchi, který jsem minulý rok vedl. Chtěl jsem totiž dětem nějak zábavně naučit základy programování a tak jsem zvolil téma počítačových her, které mě samotnému není tak blízké. To mě však vedlo k tomu, že jsem si načetl mnoho materiálů o herních smyčkách, renderování obrázků atd. což mi pak pomohlo se v těchto termínech při tvorbě této hry orientovat. 

Zprvu jsem si myslel, že využiji nějakého vývojového prostředí určeného přímo pro vývoj her, ale nakonec převládl nedostatek času se s nějakým takovým učit a také to, že jsem chtěl mít co největší kontrolu nad tím, jak si hru naprogramuji a nebýt závislý na nějakém herním enginu.

Během programování hry jsem si také zamiloval práci s GitHubem. Líbí se mi možnost, vidět chronologicky všechny své změny provedené v programu a také mít tu možnost se k nim kdykoliv vrátit. Člověku má také klid v duši když ví, že může cokoliv ve hře porouchat a má možnost se jednoduše vrátit zpět. Také mi však Git pomohl k psaní této dokumentace, jelikož umožňuje koukat se, jak se projekt vyvíjel v čase a tedy vidět logické návaznosti na sebe, jak se jednotlivé komponenty programu postupně skládaly jako dílky stavebnice.

GitHub mě oslnil natolik, že jsem se rozhodl verzovat si i tento doprovodný dokument, takže můžu hezky vidět, jak se mi tato dokumentace měnila v čase a vidět drobné úpravy, které jsem na ní dělal. Skutečnost, že Git si drží časy jednotlivých commitů mi také prospěla v tom, že jsem si lépe uvědomil, kolik času čím trávím. Je zajímavé mít tyto informace k dispozici.

Samotného mě překvapilo, jak moc mě samotná dokumentace programu pohltila. Měl jsem radost z toho, uhlazovat svůj program a odplevelovat ho od zbytečného kódu, který tam neměl co dělat a třeba se dal i zjednodušit. (Tyto nápady totiž často přicházely právě během psaní dokumentace.) Skutečnost, že mám teď jakousi verzi dokumentace sepsanou mi také otevřela dveře, abych ve volném času během prázdnil mohl hru ještě doladit o nějaké nové mechanismy. 

Na závěr bych chtěl hlavně projevit obdiv nad tím, že někdo tak propracovanou hru jako Pac-Man vytvořil už před čtyřiceti lety. Je úžasné, že toto někdo zvládnul vytvořit bez všech těch vymožeností, které nám dnes pomáhají psát kód, jako třeba skákání na reference či definice v kódu. Chytré přejmenovávání proměnných, foreach cykly a mnoho dalších zjednodušení, které mi už přijdou naprosto přirozené. No a ta umělá inteligence, která je vytvořena algoritmicky tak jednoduše, ale vede k velmi komplexně vypadajícímu chování je také úžasná. Opravdu musím říci, že původní hra Pac-Man je krásné programátorské i herně designové dílo.
\end{document}
